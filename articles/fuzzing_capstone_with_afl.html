<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Fuzzing capstone using AFL persistent mode</title>
	<link rel="stylesheet" href="style.css">
	<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-52380667-1', 'auto');
ga('send', 'pageview');
	</script>
</head>
<body>
<nav>// <a href=/>Home</a> // <a href=/about.html>About me</a> // <a href="https://github.com/toastedcornflakes">Github</a> // <div class="subtitle">— Now with 30% more cyber!</div></nav>
<h1>Fuzzing capstone using AFL persistent mode</h1>
<p>Fuzzing is an automated testing technique that involves automatically sending input to a program and monitoring its output. It's a way to test for reliability as well as identify potential security bugs. Compared to manual auditing, fuzzing will only uncover real bugs that are actually reachable. </p>
<p>Today we are fuzzing <a href="http://www.capstone-engine.org">capstone</a>. It's an open-source disassembly engine widely used in exploitation frameworks, disassemblers, debugging aids and other projects. You can take a look at a normal capstone usage <a href="http://www.capstone-engine.org/lang_c.html">here</a>.</p>
<p>The fuzzer we'll use is the hot new thing: <a href="https://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a>, AFL for short, a fuzzer that uses runtime guided techniques to create input for the tested program.</p>
<h2>Overview of the fuzzing process</h2>
<p>AFL's usual operation mode goes like this:</p>
<ul>
<li>Start (fork) a new process</li>
<li>Feed it some well chosen input</li>
<li>Monitor the code and register which path are reached using this particular input</li>
</ul>
<p>Internally, AFL checks if that input made the program reach new code path (either completely new blocks, or different sequence of blocks). If this is the case, the input is marked as 'interesting' and will be reused and remixed with other random or interesting inputs to try to reach deeper code path in the program, and yield more coverage.</p>
<p>To achieve runtime monitoring, AFL will inject code at compile time. This is done by substituting <code>gcc</code> or <code>clang</code> with AFL's wrappers: <code>afl-gcc</code> and <code>afl-clang</code>. The wrapper will call the normal compiler, then add the instrumentation code and produce a binary that can be monitored by <code>afl-fuzz</code>.</p>
<p>If you want to get a more thorough understanding of AFL's code coverage and how it generates new input, see <a href="http://lcamtuf.coredump.cx/afl/technical_details.txt">AFL's technical details</a>.</p>
<h2>Writing a test harness</h2>
<p>Let's write a test harness for the library we test, capstone. We'll keep it simple: input from stdin, and test only a small part of the library.</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>

<span class="cp">#include &quot;capstone/include/capstone.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The buffer we will pass to the library</span>
    <span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

    <span class="kt">ssize_t</span> <span class="n">read_bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

    <span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
    <span class="n">cs_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>

    <span class="c1">// cs_open and cs_disasm are the main functions needed to use capstone.</span>
    <span class="c1">// we feed them the data generated by AFL.</span>
    <span class="c1">// a normal program using capstone would then use the output of cs_disasm</span>
    <span class="c1">// to print a disassembly to the user for example</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span> <span class="o">==</span> <span class="n">CS_ERR_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">read_bytes</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>

        <span class="c1">// don&#39;t forget to clean up after ourselves</span>
        <span class="n">cs_free</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// close the capstone library</span>
    <span class="n">cs_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Let's run this with a random file as base. This is not ideal, but since the input is really small, the magic of the instrumentation should start to discover interesting values and branches pretty fast. </p>
<p>To compile this you'll need to install <a href="https://lcamtuf.coredump.cx/afl/">AFL</a> (including <code>llvm_mode</code>, needed for the next section), clang and llvm.</p>
<div class="codehilite"><pre># compile an instrumented version of capstone
git clone https://github.com/aquynh/capstone.git
cd capstone
CC=afl-clang-fast ./make.sh
cd ..

# compile and link our test harness using capstone&#39;s static library
afl-clang-fast -static harness.c capstone/libcapstone.a -o harness

# generate inputs
mkdir inputs
dd if=/dev/random of=inputs/rand bs=64 count=1
afl-fuzz -i inputs -o findings ./harness
</pre></div>


<p><img alt="first harness run" src="resources/fuzzing_capstone/harness_run.png" /></p>
<p>So far so good, AFL is running about 3.8k test/second, on just one core.</p>
<h2>Speeding things up: enter <code>AFL_PERSISTENT</code>.</h2>
<p>AFL has various tricks to speed up the fork step, but forking a process every time we want to test an input is still pretty slow. What if we could skip it entirely, and reuse the same process multiple times?</p>
<p>We are going to use AFL's in-process fuzzing. This time, we don't restart a new process for each new input. This will be <em>much</em> faster depending on the library.</p>
<p>To do so, the test harness is nearly the same: we just need to add a loop.</p>
<p>Here's the code for that:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="cp">#include &quot;capstone/include/capstone.h&quot;</span>
<span class="cp">#include &lt;inttypes.h&gt;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">csh</span> <span class="n">handle</span><span class="p">;</span>
    <span class="n">cs_insn</span> <span class="o">*</span><span class="n">insn</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span> 
    <span class="kt">ssize_t</span> <span class="n">read_bytes</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// (re-) initialize the library and read new input</span>
        <span class="n">read_bytes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
        <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
        <span class="n">read_bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cs_open</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span> <span class="o">==</span> <span class="n">CS_ERR_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// disassemble the bytes we just read using capstone</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">cs_disasm</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">read_bytes</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insn</span><span class="p">);</span>

            <span class="c1">// Don&#39;t leak memory. This is especially important in persistent mode, </span>
            <span class="c1">// because we reuse the process a significant number of times</span>
            <span class="n">cs_free</span><span class="p">(</span><span class="n">insn</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> 
        <span class="p">}</span>
        <span class="n">cs_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><code>__AFL_LOOP(1000)</code> is a macro that detects if the program is running under AFL. If it is, the loop will run 1000 times and 1000 different inputs will be fed to the library. After that, the process is torn down then restarted by AFL. This ensures we regularly replace the process to avoid memory leaks.</p>
<p>But if the program runs on his own (i.e. launched with <code>./harness_persistent</code> and not AFL) the loop runs only once. This way we can process testcases from the command line without looping a thousand time. This mean we can use gdb or automated tools to inspect the crashes found by the fuzzer using the same binary.</p>
<p>Let's try it out!</p>
<div class="codehilite"><pre>afl-clang-fast -static harness_persistent.c capstone/libcapstone.a -o harness_persistent
afl-fuzz -i inputs -o findings ./harness_persistent
</pre></div>


<p><img alt="persistent harness run" src="resources/fuzzing_capstone/harness_persistent_run.png" /></p>
<p>Twice faster! Pretty good for a 3 lines diff. The VM I use is dual core, so we can run one AFL instance per core:</p>
<div class="codehilite"><pre>afl-fuzz -i inputs -o multi_sync -M master ./fuzz_capstone
# In another tmux
afl-fuzz -i inputs -o multi_sync -S slave1 ./fuzz_capstone

# and in another pane we can get the summary stats
afl-whatsup -s multi_sync

[...]
Summary stats
=============

       Fuzzers alive : 2
      Total run time : 0 days, 0 hours
         Total execs : 25 million
    Cumulative speed : 26432 execs/sec
       Pending paths : 1 faves, 4148 total
  Pending per fuzzer : 0 faves, 2074 total (on average)
       Crashes found : 0 locally unique
</pre></div>


<p>I let that run overnight and actually found <a href="https://github.com/aquynh/capstone/issues/463">a harmless bug</a>. More on that in the next part, along with analysis  of what we found, using AFL's tools (cmin, tmin, crash exploration mode), gdb and <a href="https://github.com/bnagy/crashwalk">crashwalk</a>.</p>
<h2>Rundown</h2>
<p>In this article we  </p>
<ul>
<li>wrote a basic test harness for AFL, using stdin for providing the inputs</li>
<li>made a slightly more complicated harness that is persistent, and twice faster</li>
<li>ran the fuzzer with both</li>
</ul>
<footer>
	<div class="footerleft">
		<a href="https://twitter.com/intent/tweet?text=Fuzzing capstone using AFL persistent mode&url=https%3A%2F%2Ftoastedcornflakes.github.io%2Farticles%2Ffuzzing_capstone_with_afl%2Ehtml&via=toasted_flakes"> Tweet this</a>
	</div>
<div class="footerright">
	Want to discuss something? ⇢ <a href="mailto:toastedcornflakes@gmail.com">Get in touch</a>.
</div>
</footer>
</body>
<script src="https://www.savenetneutrality.eu/widget.js"></script>
</html>
